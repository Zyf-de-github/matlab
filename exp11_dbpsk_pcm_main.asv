clc; clear; close all;
addpath('./pcm');

%% ========= 第13组参数 =========
Rb = 64e3;                 % 比特率 
Fc = 10*Rb;                % 载波
fs = 12*Fc;                % 采样率（应满足 fs/Rb 为整数）
Ns = fs/Rb;                % 每比特采样点
assert(abs(Ns-round(Ns))<1e-12,'fs/Rb 必须为整数'); 
Ns = round(Ns);

%% ========= (A) 生成模拟输入：3 正弦叠加 =========
Fs_in = 48e3;                          % 生成"模拟信号"的采样率
Tsig  = 0.25;                          % 信号时长，秒（可调）
t_in  = (0:1/Fs_in:Tsig-1/Fs_in);

% --- 三路正弦 ---
f1=3; f2=10; f3=20;                    % 三个频率
a1=0.8; a2=0.5; a3=0.3;                % 不同幅度

sig1 = a1*sin(2*pi*f1*t_in);
sig2 = a2*sin(2*pi*f2*t_in);
sig3 = a3*sin(2*pi*f3*t_in);

% --- 合成并归一 ---
y_analog = sig1 + sig2 + sig3;
y_analog = y_analog/max(abs(y_analog))*0.98;   % 归一防溢

% --- 画三路 + 合成波形 ---
figure;
plot(t_in, sig1, 'r'); hold on;
plot(t_in, sig2, 'g');
plot(t_in, sig3, 'b');
plot(t_in, y_analog, 'w','LineWidth',1.2);
grid on;
legend('sin1','sin2','sin3','sum');
title('输入模拟信号（3正弦叠加 + 单独显示三路）');
xlabel('t/s'); ylabel('amp');

%% ========= (B) PCM 13 折线编码（8kHz） =========
sampleVal = Rb/8; % 8 kHz ⇒ 8 bit/样本 ⇒ 64 kbps，刚好匹配 Rb
[sampleData, bits_pcm] = PCM_13Encode(y_analog, Fs_in, sampleVal);

% PCM 抽样后波形
t_smp = (0:numel(sampleData)-1)/sampleVal;
figure; plot(t_smp, sampleData); grid on;
title('PCM 抽样后波形'); xlabel('t/s');

% PCM 编码 bit 流（截前 100 位展示）
figure; stairs(bits_pcm(1:100)); ylim([-0.2 1.2]); grid on;
title('PCM 编码后 bit（前 100 位）');

%% ========= (C.X) 码型变换：矩形脉冲 vs SRRC 脉冲（仅用于演示） =========

% 取前 20 个比特做脉冲展示（太多画不清楚）
Nshow = 20;
bps = bits_pcm(1:Nshow);

% bit → ±1
symbols_demo = 2*bps - 1;

% SRRC 参数（演示 + 正式都用同一组）
beta = 0.75;          % 滚降系数
span = 8;             % 滤波器跨度（符号数）
srrc = rcosdesign(beta, span, Ns, 'sqrt');   % 根升余弦脉冲

% ========== 1) 矩形脉冲（未成形）==========
rect = upsample(symbols_demo, Ns);              % 上采样
rect_wave = filter(ones(1, Ns), 1, rect);       % 简单矩形成形

% ========== 2) SRRC 脉冲（根升余弦）==========
srrc_wave_demo = filter(srrc, 1, upsample(symbols_demo, Ns));

% ========== 画两者对比 ==========
figure;
subplot(2,1,1);
plot(rect_wave, 'b'); grid on;
title('矩形脉冲成形（矩形滤波器）');
ylabel('幅度');
xlim([0, Nshow*Ns]);

subplot(2,1,2);
plot(srrc_wave_demo, 'r'); grid on;
title('SRRC 脉冲成形（根升余弦）');
xlabel('样本点'); ylabel('幅度');
xlim([0, Nshow*Ns]);

%% ========= (C.Y) 乘法器：脉冲成形后的调制（基带 → 带通，演示） =========

% 时间轴匹配（取与 rect_wave 相同长度）
t_show = (0:length(rect_wave)-1)/fs;
carrier_demo = cos(2*pi*Fc*t_show);

% 1) 矩形脉冲 × 载波（演示）
rect_mod = rect_wave .* carrier_demo;

% 2) SRRC 脉冲 × 载波（演示）
srrc_mod_demo = srrc_wave_demo .* carrier_demo;

Nplot = min(2000, length(rect_wave));   % 演示画前 2000 点

figure;
subplot(2,2,1);
plot(rect_wave(1:Nplot),'b'); grid on;
title('矩形脉冲（基带）');
ylabel('幅度');

subplot(2,2,2);
plot(rect_mod(1:Nplot),'b'); grid on;
title('矩形脉冲 × cos(2πF_ct)（带通）');
ylim([-2 2]);

subplot(2,2,3);
plot(srrc_wave_demo(1:Nplot),'r'); grid on;
title('SRRC 脉冲（基带）');
xlabel('样本点'); ylabel('幅度');

subplot(2,2,4);
plot(srrc_mod_demo(1:Nplot),'r'); grid on;
title('SRRC 脉冲 × cos(2πF_ct)（带通）');
xlabel('样本点');

%% ========= (C.Z) 演示：SRRC 调制 vs 未成形调制 的频谱 =========

Nfft = min([4096, length(rect_mod), length(srrc_mod_demo)]);

[fx_rect, S_rect]   = simple_spectrum(rect_mod(1:Nfft), fs);
[fx_srrc, S_srrc]   = simple_spectrum(srrc_mod_demo(1:Nfft), fs);

figure;
subplot(2,1,1);
plot(fx_rect/1e6, 20*log10(abs(S_rect)+1e-12), 'b'); grid on;
title('未成形（矩形脉冲）调制后的带通信号频谱');
xlabel('f / MHz'); ylabel('|X(f)| dB');

subplot(2,1,2);
plot(fx_srrc/1e6, 20*log10(abs(S_srrc)+1e-12), 'r'); grid on;
title('SRRC 脉冲成形后调制的带通信号频谱');
xlabel('f / MHz'); ylabel('|X(f)| dB');

%% ========= (C.real) 正式 DBPSK + SRRC 调制链路（后续解调用） =========
disp("正在生成正式 DBPSK + SRRC 调制信号...");

% 1) 全部 PCM bit → ±1
symbols_full = 2*bits_pcm - 1;

% 2) DBPSK 差分编码
diff_syms = zeros(size(symbols_full));
diff_syms(1) = symbols_full(1);
for k = 2:length(symbols_full)
    diff_syms(k) = diff_syms(k-1)*symbols_full(k);
end

% 3) 上采样
up_syms = upsample(diff_syms, Ns);

% 4) SRRC 脉冲成形（正式基带）
tx_bb = filter(srrc, 1, up_syms);    % ★ 正式发射基带信号

% 5) 带通调制
t = (0:length(tx_bb)-1)/fs;
tx = tx_bb .* cos(2*pi*Fc*t);        % ★ 正式发射带通信号

disp("正式 SRRC 调制信号生成完毕。");

% 画正式已调信号频谱
[fx, SX] = simple_spectrum(tx, fs);
figure; plot(fx/1e6, 20*log10(abs(SX)+1e-12)); grid on;
xlabel('f / MHz'); ylabel('|X(f)| dB'); title('正式已调信号幅度谱（dB）');

%% ========= (D) 加噪（AWGN 信道） =========
SNRdB = 10;  % 单点演示
tx_pow = mean(tx.^2);
npow   = tx_pow/10^(SNRdB/10);
noise  = sqrt(npow)*randn(size(tx));
% rx     = tx + noise;
rx=tx;

% 波形片段（时域对比）
seg = 1:min(4000, numel(t));
figure; plot(t(seg), tx(seg), 'b', t(seg), rx(seg), 'r'); grid on;
legend('tx','rx'); 
title(sprintf('DBPSK 已调与加噪后波形, SNR=%.1f dB',SNRdB));
xlabel('t/s');

%% ========= (D.X) 接收端：乘法器 × SRRC 匹配滤波 =========

t_rx = (0:length(rx)-1)/fs;
local_carrier = cos(2*pi*Fc*t_rx);

% 带通 → 基带
rx_bb = rx .* local_carrier;

% 匹配滤波（SRRC）
rx_matched = filter(srrc, 1, rx_bb);

% 画 rx / rx×cos / 匹配后
figure;
Nplot2 = min(2000, length(rx));
subplot(3,1,1);
plot(rx(1:Nplot2),'b'); grid on;
title('接收信号 rx（带通）');

subplot(3,1,2);
plot(rx_bb(1:Nplot2),'m'); grid on;
title('rx × cos(2πF_ct)（乘法器输出，基带）');

subplot(3,1,3);
plot(rx_matched(1:Nplot2),'r'); grid on;
title('SRRC 匹配滤波输出（基带信号）');
xlabel('样本点');

%% ========= (E) DBPSK 解调（差分乘积+滑动平均） =========
delay = span * Ns / 2;  % 和前面对齐用的是同一个 span, Ns
rx_for_demod = rx_matched(delay+1 : end);  % 丢掉前 delay 个点
[bits_hat, eye_buf] = DBPSK_Demod(rx_matched, fs, Rb);

% 对齐比特长度为 8 的整数倍（便于 PCM 解码）
L_bits = floor(numel(bits_hat) / 8) * 8;
bits_hat = bits_hat(1:L_bits);
bits_ref = bits_pcm(1:L_bits);

%% ========= (E.X) SRRC 匹配滤波输出 vs 发射基带 vs 抽样点 =========
disp('绘制 SRRC 匹配滤波输出与发射基带、抽样点比较...');

% 1) 发射端 SRRC 基带信号
tx_bb_full = tx_bb;

% 2) 接收端匹配滤波输出
rx_bb_full = rx_matched;

% 3) 估算群时延，并对齐
delay = span * Ns / 2;              % 大约群时延
L_tx   = length(tx_bb_full);
L_rx   = length(rx_bb_full);
L_valid = min(L_tx, L_rx - delay);
if L_valid > 0
    tx_aligned = tx_bb_full(1:L_valid);
    rx_aligned = rx_bb_full(delay+1 : delay+L_valid);

    Nplot3 = min(3000, L_valid);
    figure;
    plot(tx_aligned(1:Nplot3),'b'); hold on;
    plot(rx_aligned(1:Nplot3),'r'); grid on;
    legend('TX：SRRC 脉冲成形基带','RX：SRRC 匹配滤波输出（对齐后）');
    title('SRRC 发射基带 vs 接收匹配滤波基带 对比');
    xlabel('样本点');
end

% ==== 自动符号同步：寻找 SRRC 匹配滤波输出的第一个脉冲峰值 ====

search_len = min(5*Ns, length(rx_matched));
search_region = abs(rx_matched(1:search_len));

[~, peak_pos] = max(search_region);

sample_pos = peak_pos + (0:length(bits_ref)-1)*Ns;
sample_pos = sample_pos(sample_pos <= length(rx_matched));

rx_samples = rx_matched(sample_pos);
rx_decision = rx_samples > 0;


% 5) 比特对比（原始 PCM bit vs 直接幅度判决 bit）
Nshow_bits = min(500, length(rx_decision));
figure;
subplot(2,1,1);
stem(1:Nshow_bits, bits_ref(1:Nshow_bits),'b','LineWidth',1.2);
grid on;
title('原始 PCM 比特（截取前 60 位）');
ylabel('bit'); xlim([1 Nshow_bits]);

subplot(2,1,2);
stem(1:Nshow_bits, rx_decision(1:Nshow_bits),'r','LineWidth',1.2);
grid on;
title('SRRC 抽样幅度判决得到的比特（示意，非正式解调）');
xlabel('符号编号'); ylabel('bit'); xlim([1 Nshow_bits]);

% 6) SRRC 基带 + 抽样点标注
Nplot_srrc = min(5000, length(rx_bb_full));
figure;
plot(rx_bb_full(1:Nplot_srrc),'m'); hold on; grid on;
sample_pos_valid = sample_pos(sample_pos <= Nplot_srrc);
stem(sample_pos_valid, rx_bb_full(sample_pos_valid),'r','filled');
title('SRRC 匹配滤波基带信号 + 抽样点标注');
xlabel('样本编号'); ylabel('幅度');
legend('SRRC 基带','抽样点');


%% ========= (F) BER 计算 =========
BER_now = mean(xor(bits_ref, bits_hat));
fprintf('单点 SNR = %.1f dB 时，BER = %.4e\n', SNRdB, BER_now);

% =========================================================
%   (FX) 四图对比：PCM 原始波形/抽样 & SRRC 波形/抽样
%             PCM 原始比特 & DBPSK 解调比特
% =========================================================

disp("绘制『四图对比』：PCM波形、SRRC波形、PCM比特、解调比特...");

% ========= ① PCM 原始采样波形 + PCM 抽样点 =========
Nplot_pcm = min(500, length(sampleData));

figure;
subplot(2,1,1);
plot(t_smp(1:Nplot_pcm), sampleData(1:Nplot_pcm),'b'); hold on; grid on;
title('① PCM 原始采样波形');
xlabel('时间 (s)'); ylabel('幅度');

% PCM 理论抽样点（每 1/sampleVal 秒一个）
sampleIndex_pcm = (0:length(bits_ref)-1) * (1/sampleVal);
sampleIndex_pcm = sampleIndex_pcm(sampleIndex_pcm < t_smp(end));

pcm_sample_pos = round(sampleIndex_pcm * sampleVal + 1);
pcm_sample_pos = pcm_sample_pos(pcm_sample_pos <= length(sampleData));

stem(t_smp(pcm_sample_pos), sampleData(pcm_sample_pos),'r','filled');
legend('PCM 波形','PCM 抽样点');


% ========= ② SRRC 匹配滤波后的基带波形 + 抽样点 =========
Nplot_srrc = min(5000, length(rx_matched));

subplot(2,1,2);
plot(rx_matched(1:Nplot_srrc),'m'); hold on; grid on;
title('② SRRC 匹配滤波基带信号 + 抽样点标注');
xlabel('样本编号'); ylabel('幅度');

sample_pos_valid = sample_pos(sample_pos <= Nplot_srrc);
stem(sample_pos_valid, rx_matched(sample_pos_valid),'r','filled');
legend('SRRC 基带','抽样点');


% ========= ③ PCM 原始比特 =========
Nshow_bits = min(80, length(bits_ref));  % 展示前 80 个比特

figure;
subplot(2,1,1);
stem(1:Nshow_bits, bits_ref(1:Nshow_bits),'b','LineWidth',1.2);
grid on;
title('③ PCM 原始比特（前 80 位）');
xlabel('符号编号'); ylabel('bit');
xlim([1 Nshow_bits]);


% ========= ④ DBPSK 解调最终比特（bits_hat） =========
subplot(2,1,2);
stem(1:Nshow_bits, bits_hat(1:Nshow_bits),'r','LineWidth',1.2);
grid on;
title('④ DBPSK 解调比特（前 80 位）');
xlabel('符号编号'); ylabel('bit');
xlim([1 Nshow_bits]);


%% ========= (G) 眼图（使用 DBPSK_Demod 输出的 eye_buf） =========
Ns = fs/Rb;
Leye = floor(length(eye_buf)/Ns) * Ns;   % 对齐到符号整数倍
if Leye > 0
    eye_mat = reshape(eye_buf(1:Leye), Ns, []);
    figure;
    plot(eye_mat(:, 1: min(40, size(eye_mat,2))), 'y'); grid on;
    title('接收端眼图（差分能量轨迹）');
    xlabel('样本点'); ylabel('幅度');
end

%% ========= (H) 频谱：输入/输出模拟信号 =========
% 输入模拟信号频谱（原48k）
[fa, SA] = simple_spectrum(y_analog, Fs_in);
figure; plot(fa/1e3, 20*log10(abs(SA)+1e-12)); grid on;
xlabel('f / kHz'); ylabel('|S(f)| dB'); title('输入模拟信号频谱');

% PCM 解码回"模拟"信号（8kHz 域）
outData = PCM_13Decode(bits_hat);
t_out = (0:numel(outData)-1)/sampleVal;

figure; plot(t_smp, sampleData,'b'); hold on;
plot(t_out, outData,'r'); grid on;
legend('PCM 抽样后(发送侧)','PCM 解码后(接收侧)');
title('输入/输出 "模拟" 波形（8kHz 域）'); xlabel('t/s');

[fo, SO] = simple_spectrum(outData, sampleVal);
figure; plot(fo/1e3, 20*log10(abs(SO)+1e-12)); grid on;
xlabel('f / kHz'); ylabel('|S(f)| dB'); title('输出模拟信号频谱（解码后）');

%% ========= (I) BER 曲线：SNR 扫描 =========
SNRs = 0:2:14;  
BERs = zeros(size(SNRs));

for k = 1:numel(SNRs)
    npow_k = tx_pow/10^(SNRs(k)/10);
    n_k    = sqrt(npow_k)*randn(size(tx));
    r_k    = tx + n_k;

    t_rx_k = (0:length(r_k)-1)/fs;
    local_carrier_k = cos(2*pi*Fc*t_rx_k);
    r_bb_k = r_k .* local_carrier_k;
    r_mf_k = filter(srrc, 1, r_bb_k);
    r_for_demod = r_matched(delay+1 : end);

    [bhat, ~] = DBPSK_Demod(r_for_demod, fs, Rb);
    [bhat_k, ~] = DBPSK_Demod(r_mf_k, fs, Rb);
    Lk = floor(min(numel(bhat_k), numel(bits_pcm))/8)*8;
    BERs(k) = mean(xor(bits_pcm(1:Lk), bhat_k(1:Lk)));
end

figure; semilogy(SNRs, BERs,'-o'); grid on;
xlabel('SNR / dB'); ylabel('BER'); title('DBPSK + SRRC 误码率曲线');

%% ========= (J) （可选）硬件 DA 输出 =========
% 若要上板到示波器看 I/Q：
% CH1 = rx(1:2:end); 
% CH2 = rx(2:2:end);  
% divFreq = 30720000/fs - 1;  
% isGain = 1;
% DA_OUT(CH1, CH2, divFreq, length(CH1), isGain);


% [sampleData, bits_pcm] = PCM_13Encode(y_analog, Fs_in, sampleVal);
% outData_pcm_only = PCM_13Decode(bits_pcm);
% 
% t_smp = (0:numel(sampleData)-1)/sampleVal;
% 
% figure;
% plot(t_smp, sampleData, 'b'); hold on;
% plot(t_smp, outData_pcm_only, 'r');
% grid on;
% legend('PCM 抽样后(原始)','PCM 只编解码后');
% title('仅 PCM 编解码效果对比');
% xlabel('t/s');

% % 暂时禁用 SRRC 和噪声，只看 DBPSK_Demod 的 BER
% [~, tx_nosrrc] = DBPSK_Modulation(bits_pcm, Fc, fs, Rb);
% rx_test = tx_nosrrc;   % 不加噪
% 
% [bits_hat_test, ~] = DBPSK_Demod(rx_test, fs, Rb);
% Ltest = floor(min(numel(bits_hat_test), numel(bits_pcm))/8)*8;
% BER_test = mean(xor(bits_pcm(1:Ltest), bits_hat_test(1:Ltest)));
% fprintf('仅 DBPSK (无噪、无SRRC) 的 BER = %.4e\n', BER_test);
